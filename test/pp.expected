type v =
  | A of string * bool 
  | B of float 
  | C [@@deriving (brr, (show { with_path = false }))]
let rec pp_v
  : Ppx_deriving_runtime.Format.formatter -> v -> Ppx_deriving_runtime.unit =
  ((let open! ((Ppx_deriving_runtime)[@ocaml.warning "-A"]) in
      fun fmt ->
        function
        | A (a0, a1) ->
            (Ppx_deriving_runtime.Format.fprintf fmt "(@[<2>A (@,";
             ((Ppx_deriving_runtime.Format.fprintf fmt "%S") a0;
              Ppx_deriving_runtime.Format.fprintf fmt ",@ ";
              (Ppx_deriving_runtime.Format.fprintf fmt "%B") a1);
             Ppx_deriving_runtime.Format.fprintf fmt "@,))@]")
        | B a0 ->
            (Ppx_deriving_runtime.Format.fprintf fmt "(@[<2>B@ ";
             (Ppx_deriving_runtime.Format.fprintf fmt "%F") a0;
             Ppx_deriving_runtime.Format.fprintf fmt "@])")
        | C -> Ppx_deriving_runtime.Format.pp_print_string fmt "C")
  [@ocaml.warning "-A"])
and show_v : v -> Ppx_deriving_runtime.string =
  fun x -> Ppx_deriving_runtime.Format.asprintf "%a" pp_v x[@@ocaml.warning
                                                             "-32"]
include
  struct
    let _ = fun (_ : v) -> ()
    let v_to_jv t =
      match t with
      | A (v0, v1) ->
          let a = Jv.Jarray.create 3 in
          (Jv.Jarray.set a 0 (Jv.of_string "A");
           (Jv.Jarray.set a 1 (Jv.of_string v0);
            Jv.Jarray.set a 2 (Jv.of_bool v1));
           a)
      | B v0 ->
          let a = Jv.Jarray.create 2 in
          (Jv.Jarray.set a 0 (Jv.of_string "B");
           Jv.Jarray.set a 1 (Jv.of_float v0);
           a)
      | C ->
          let a = Jv.Jarray.create 1 in
          (Jv.Jarray.set a 0 (Jv.of_string "C"); (); a)
    let _ = v_to_jv
    let v_of_jv t =
      ((match Jv.to_string (Jv.Jarray.get t 0) with
        | "A" ->
            A
              ((Jv.to_string (Jv.Jarray.get t 1)),
                (Jv.to_bool (Jv.Jarray.get t 2)))
        | "B" -> B (Jv.to_float (Jv.Jarray.get t 1))
        | "C" -> C)
      [@warning "-8"])
    let _ = v_of_jv
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
type r = {
  x: v ;
  y: int }[@@deriving (brr, (show { with_path = false }))]
let rec pp_r :
  Ppx_deriving_runtime.Format.formatter -> r -> Ppx_deriving_runtime.unit =
  let __0 () = pp_v in
  ((let open! ((Ppx_deriving_runtime)[@ocaml.warning "-A"]) in
      fun fmt ->
        fun x ->
          Ppx_deriving_runtime.Format.fprintf fmt "@[<2>{ ";
          ((Ppx_deriving_runtime.Format.fprintf fmt "@[%s =@ " "x";
            ((__0 ()) fmt) x.x;
            Ppx_deriving_runtime.Format.fprintf fmt "@]");
           Ppx_deriving_runtime.Format.fprintf fmt ";@ ";
           Ppx_deriving_runtime.Format.fprintf fmt "@[%s =@ " "y";
           (Ppx_deriving_runtime.Format.fprintf fmt "%d") x.y;
           Ppx_deriving_runtime.Format.fprintf fmt "@]");
          Ppx_deriving_runtime.Format.fprintf fmt "@ }@]")
    [@ocaml.warning "-A"])
and show_r : r -> Ppx_deriving_runtime.string =
  fun x -> Ppx_deriving_runtime.Format.asprintf "%a" pp_r x[@@ocaml.warning
                                                             "-32"]
include
  struct
    let _ = fun (_ : r) -> ()
    let r_to_jv { x; y } = Jv.obj [|("x", (v_to_jv x));("y", (Jv.of_int y))|]
    let _ = r_to_jv
    let r_of_jv j =
      { x = (v_of_jv (Jv.get j "x")); y = (Jv.to_int (Jv.get j "y")) }
    let _ = r_of_jv
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
type 'a t =
  | Nil 
  | Cons of 'a * 'a t [@@deriving (brr, (show { with_path = false }))]
let rec pp :
  'a .
    (Ppx_deriving_runtime.Format.formatter -> 'a -> Ppx_deriving_runtime.unit)
      ->
      Ppx_deriving_runtime.Format.formatter ->
        'a t -> Ppx_deriving_runtime.unit
  =
  let __0 () = pp in
  ((let open! ((Ppx_deriving_runtime)[@ocaml.warning "-A"]) in
      fun poly_a ->
        fun fmt ->
          function
          | Nil -> Ppx_deriving_runtime.Format.pp_print_string fmt "Nil"
          | Cons (a0, a1) ->
              (Ppx_deriving_runtime.Format.fprintf fmt "(@[<2>Cons (@,";
               ((poly_a fmt) a0;
                Ppx_deriving_runtime.Format.fprintf fmt ",@ ";
                ((__0 ()) (fun fmt -> poly_a fmt) fmt) a1);
               Ppx_deriving_runtime.Format.fprintf fmt "@,))@]"))
    [@ocaml.warning "-A"])
and show :
  'a .
    (Ppx_deriving_runtime.Format.formatter -> 'a -> Ppx_deriving_runtime.unit)
      -> 'a t -> Ppx_deriving_runtime.string
  =
  fun poly_a ->
    fun x -> Ppx_deriving_runtime.Format.asprintf "%a" (pp poly_a) x[@@ocaml.warning
                                                                    "-32"]
include
  struct
    let _ = fun (_ : 'a t) -> ()
    let rec t_to_jv a_to_jv t =
      match t with
      | Nil ->
          let a = Jv.Jarray.create 1 in
          (Jv.Jarray.set a 0 (Jv.of_string "Nil"); (); a)
      | Cons (v0, v1) ->
          let a = Jv.Jarray.create 3 in
          (Jv.Jarray.set a 0 (Jv.of_string "Cons");
           (Jv.Jarray.set a 1 (a_to_jv v0);
            Jv.Jarray.set a 2 ((t_to_jv a_to_jv) v1));
           a)
    let _ = t_to_jv
    let rec t_of_jv a_of_jv t =
      ((match Jv.to_string (Jv.Jarray.get t 0) with
        | "Nil" -> Nil
        | "Cons" ->
            Cons
              ((a_of_jv (Jv.Jarray.get t 1)),
                (t_of_jv a_of_jv (Jv.Jarray.get t 2))))
      [@warning "-8"])
    let _ = t_of_jv
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
type s1 =
  | S1 of int t [@@deriving brr]
include
  struct
    let _ = fun (_ : s1) -> ()
    let s1_to_jv t =
      match t with
      | S1 v0 ->
          let a = Jv.Jarray.create 2 in
          (Jv.Jarray.set a 0 (Jv.of_string "S1");
           Jv.Jarray.set a 1 ((t_to_jv Jv.of_int) v0);
           a)
    let _ = s1_to_jv
    let s1_of_jv t =
      ((match Jv.to_string (Jv.Jarray.get t 0) with
        | "S1" -> S1 (t_of_jv Jv.to_int (Jv.Jarray.get t 1)))
      [@warning "-8"])
    let _ = s1_of_jv
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
type 'a s =
  | S of 'a t [@@deriving brr]
include
  struct
    let _ = fun (_ : 'a s) -> ()
    let s_to_jv a_to_jv t =
      match t with
      | S v0 ->
          let a = Jv.Jarray.create 2 in
          (Jv.Jarray.set a 0 (Jv.of_string "S");
           Jv.Jarray.set a 1 ((t_to_jv a_to_jv) v0);
           a)
    let _ = s_to_jv
    let s_of_jv a_of_jv t =
      ((match Jv.to_string (Jv.Jarray.get t 0) with
        | "S" -> S (t_of_jv a_of_jv (Jv.Jarray.get t 1)))
      [@warning "-8"])
    let _ = s_of_jv
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
let () =
  let p x = Brr.Console.log [x] in
  let data = { x = (A ("hi", false)); y = 2 } in
  p (r_to_jv data);
  p (r_to_jv { x = (B 1.); y = 3 });
  p (r_to_jv { x = C; y = 4 });
  (let xs = Cons (1, Nil) in
   p (t_to_jv Jv.of_int xs);
   p (s1_to_jv (S1 xs));
   p (s_to_jv Jv.of_int (S xs));
   (let rt = t_of_jv Jv.to_int (t_to_jv Jv.of_int xs) in
    Format.printf "%a@." (pp Format.pp_print_int) rt;
    (let rt1 = r_of_jv (r_to_jv data) in Format.printf "%a@." pp_r rt1)))
